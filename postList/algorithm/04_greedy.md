---
title: "욕심쟁이 방법 알고리즘"
permalink: algorithm/04_greedy
toc_label: "<a href='/algorithm/'>알고리즘 홈이동 Click</a>"
layout: single
comments: true
read_time: true
share: true
related: true
toc: true
toc_ads: true
toc_sticky: true
sidebar:
  nav: "algorithm"
---
[알고리즘 바로가기](../algorithm)


## # 욕심쟁이 방법의 원리
- 해를 구하는 일련의 선택 단계마다 전후 단계의 선택과는 무관하게 해당 단계에서 최선이라고 여겨지는 국부적인 최적해를 선택함으로써 전체적인 최적해를 구하는 방법
  + "greedy" -> 탐욕적 방법, 탐욕 알고리즘, 그리디 알고리즘

### 동적 프로그래밍 / 욕심쟁이 방법 비교
1. 두 알고리즘 모두 최적화 문제 해결에 주로 사용되고  최적성의 원리가 적용 된다, 그 예로는 최솟값이나 최댓값을 구하는 문제 등이 있다. 
2. 동적 프로그래밍의 경우 소문제의 여러 최적해로부터 다음 크기의 문제에 대한 최적해가 결정 되는 방식으로 항상 전체적인 최적해를 구한다. 이에 반해 욕심쟁이 방법은 소문제에 대해서 하나의 최적해만 고려하게 되므로 전체적인 최적해를 구하지는 못한다.

### 욕심쟁이 방법의 한계
- 각 단계에서만의 최적해를 구하므로 해당 단계에서는 최고의 선택이지만 전체적으로 봤을 때는 가장 최고의 선택이라고 할수는 없다. 그러므로 전체적으로 봐야하는 문제에서는 욕심쟁이 방법으로 해를 구할 수 없는 문제도 많다.

## 1. 동전 거스름돈 문제
- 고객에게 돌려줄 거스름돈이 있을 때 고객이 받을 동전의 개수를 최소로 하여 거스름돈을 돌려주는 방법을 찾는 문제
- 기본 접근방법
  + 거스름돈의 액수를 초과하지 않는 조건
  + 단순히 액면가가 큰 동전부터 '욕심을 부려서' 거스름돈을 만듦

### 알고리즘 구성
```
입력 T : 고객에게 돌려줄 거스름돈, 
입력 n : 동전의 종류
C[0 .. n-1] : 동전의 액면가를 감소순으로 저장 (500 -> 100 -> 50 -> 10)
출력 X[0 .. n-1] : 거스름돈으로 돌려줄 i번째 동전의 개수
```
1. 동전의 갯수만큼 반복문 생성
2. 액면가가 큰 동전부터 최대 갯수를 뽑고
3. 전체금액에서 계산된 잔돈을 빼고 다시 반복

### 성능 분석
- 동전의 종류 만큼(n) 시간이 걸리게 된다 그래서 빅오 표기법으로는 O(n) 의 시간복잡도를 가지게 된다.

### 특징
- 동전의 액면가가 임의로 주어지는 일반적인 경우
  + 동전의 종류 : 500원, 120원, 100원, 50원, 10원
- 동전의 액면가가 임의로 주어진다면 거스름돈 문제는 욕심쟁이 방법으로 해결이 불가능 하다. 즉 최적해를 찾을 수가 없다. 이를 해결하기 위해서는 **동적프로그램 방법**으로 해결해야 한다.

## 2. 배낭 문제
- 최대 용량 M(kg)인 하나의 배낭과 n개의 물체